ECM OVS flow look up failed in connection less traffic (UDP)

In ECM OVS we use flow table to construct the outer interfaces list, but
in connection less traffic, we might not find the reverse flow yet when
we construct the hierarchy.
When we failed to find out the flow, we would trigger to send the ARP
request to resolve it.
Once we get the response, the OVS flow table will re-learn the reverse
connection flow. Afterwards the hierarchy construction would succeed.

--- a/ecm_interface.c
+++ b/ecm_interface.c
@@ -3693,14 +3693,47 @@ int32_t ecm_interface_heirarchy_construc
 				if (!ovs_internal_dev_cnt && ovs_is_internal_dev(dest_dev)) {
 					struct net_device *outer_dev = NULL;
 					uint8_t mac_addr[ETH_ALEN];
+					ip_addr_t gw_addr = ECM_IP_ADDR_NULL;
+					bool on_link = false;
+					bool not_found = false;
 
 					ovs_internal_dev_cnt = 1;
-					memset(mac_addr, 0, ETH_ALEN);
-					if (ecm_interface_multicast_get_next_node_mac_address(next_dest_addr, dest_dev, ip_version, mac_addr)) {
-						outer_dev = ovs_port_dev_get(dest_dev, mac_addr, ip_version, NULL);
-						if (outer_dev) {
-			   				next_dev = outer_dev;
+					if (likely(ecm_interface_mac_addr_get(next_dest_addr, mac_addr, &on_link, gw_addr))) {
+						/* In construction to_nat interface list, the dest_dev is br-wan, and the interested device mac is also br-wan mac.
+						 * This would result the ovs look up failed and repeatedly re-construct the interface hierarchy.
+						 * The workaround here is to check the condition and avoid it.
+						 */
+						if (memcmp(dest_dev->dev_addr, mac_addr, ETH_ALEN)) {
+							outer_dev = ovs_port_dev_get(dest_dev, mac_addr, ip_version, NULL);
+							if (outer_dev) {
+								next_dev = outer_dev;
+							} else {
+								not_found = true;
+							}
 						}
+					} else {
+						not_found = true;
+					}
+
+					if (not_found) {
+						//printk("Unable to obtain outer interface for: %pM\n", mac_addr);
+						/* send ARP request to revnew the flow table */
+						if (ip_version == 4) {
+							ecm_interface_send_arp_request(dest_dev, next_dest_addr, on_link, gw_addr);
+						}
+#ifdef ECM_IPV6_ENABLE
+						else if (ip_version == 6) {
+							ecm_interface_send_neighbour_solicitation(dest_dev, next_dest_addr);
+						}
+#endif
+						dev_put(src_dev);
+						dev_put(dest_dev);
+
+						/*
+						 * Release the interfaces heirarchy we constructed to this point.
+						 */
+						ecm_db_connection_interfaces_deref(interfaces, current_interface_index);
+						return ECM_DB_IFACE_HEIRARCHY_MAX;
 					}
 				}
 
